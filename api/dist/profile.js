"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.profileRouter = void 0;
const express_1 = require("express");
const prisma_1 = require("./prisma");
const auth_1 = require("./middleware/auth");
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const axios_1 = __importDefault(require("axios"));
const uuid_1 = require("uuid");
const nsfw_1 = require("./nsfw");
const trust_1 = require("./trust");
const profileRouter = (0, express_1.Router)();
exports.profileRouter = profileRouter;
// ‚úÖ –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –¥–æ –∫–æ—Ä–Ω—è CDN-–∫–∞—Ç–∞–ª–æ–≥–∞
const CDN_ROOT_PATH = "/var/www/spectrmod/cdn/image";
profileRouter.get("/profile/me", auth_1.authMiddleware, async (req, res) => {
    const userId = req.userId;
    const profile = await prisma_1.prisma.profile.findUnique({
        where: { userId },
        include: {
            user: {
                select: {
                    id: true,
                    username: true,
                    isAdmin: true,
                    isModerator: true,
                    isAdvertiser: true
                }
            }
        }
    });
    if (!profile) {
        res.status(404).json({ error: "Profile not found" });
        return;
    }
    res.json({ profile });
});
profileRouter.post("/profile/create", auth_1.authMiddleware, async (req, res) => {
    const userId = req.userId;
    const { preferredName, gender, birthYear, city, goals, description, images } = req.body;
    const existing = await prisma_1.prisma.profile.findUnique({ where: { userId } });
    if (existing) {
        res.status(400).json({ error: "Profile already exists" });
        return;
    }
    if (!preferredName || !gender || !birthYear || !city ||
        !goals || !Array.isArray(goals) || goals.length === 0 ||
        !description || description.length < 10) {
        res.status(400).json({ error: "Invalid profile data" });
        return;
    }
    const user = await prisma_1.prisma.user.findUnique({ where: { id: userId } });
    const fallbackImage = user?.username
        ? `https://api.dicebear.com/7.x/thumbs/svg?seed=${Math.floor(Math.random() * 1000000)}`
        : undefined;
    const profile = await prisma_1.prisma.profile.create({
        data: {
            userId,
            preferredName,
            gender,
            birthYear,
            city,
            goals,
            description,
            images: images?.length > 0 ? images : (fallbackImage ? [fallbackImage] : []),
        },
    });
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª–Ω–æ—Ç—É –ø—Ä–æ—Ñ–∏–ª—è –∏ –æ–±–Ω–æ–≤–ª—è–µ–º trust score
    await (0, trust_1.checkProfileCompleteness)(userId);
    res.json({ profile });
});
profileRouter.get("/profile/:profileId", async (req, res) => {
    const { profileId } = req.params;
    if (!profileId) {
        res.status(400).json({ error: "profileId is required" });
        return;
    }
    try {
        const profile = await prisma_1.prisma.profile.findUnique({
            where: { id: profileId },
            include: {
                user: {
                    select: {
                        id: true,
                        username: true,
                    },
                },
            },
        });
        if (!profile) {
            res.status(404).json({ error: "Profile not found" });
            return;
        }
        res.json({ profile });
    }
    catch (err) {
        console.error("[API] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:", err);
        res.status(500).json({ error: "Internal server error" });
    }
});
profileRouter.get("/profile/by-telegram/:telegramId", async (req, res) => {
    const { telegramId } = req.params;
    if (!telegramId) {
        res.status(400).json({ error: "telegramId is required" });
        return;
    }
    try {
        const user = await prisma_1.prisma.user.findUnique({
            where: { telegramId: BigInt(telegramId) },
            include: { profile: true },
        });
        res.json({
            exists: !!user?.profile,
            profile: user?.profile
                ? { id: user.profile.id, images: user.profile.images }
                : null,
        });
    }
    catch (err) {
        console.error("[API] by-telegram error", err);
        res.status(500).json({ error: "internal" });
    }
});
profileRouter.post("/profile/add-media", async (req, res) => {
    const { telegramId, imageUrl, skipNsfwCheck = false } = req.body;
    if (!telegramId || !imageUrl) {
        res.status(400).json({ error: "telegramId and imageUrl are required" });
        return;
    }
    try {
        const user = await prisma_1.prisma.user.findUnique({
            where: { telegramId: BigInt(telegramId) },
            include: {
                profile: {
                    include: {
                        imageData: true
                    }
                }
            },
        });
        if (!user?.profile) {
            res.status(404).json({ error: "Profile not found" });
            return;
        }
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–±–µ—Ä–µ–º –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ –º–∞—Å—Å–∏–≤–∞, —Ç–∞–∫ –∫–∞–∫ –æ–Ω —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω)
        const totalImages = user.profile.images.length;
        if (totalImages >= 5) {
            res.status(400).json({ error: "Maximum 5 images allowed" });
            return;
        }
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        const response = await axios_1.default.get(imageUrl, {
            responseType: "arraybuffer",
            timeout: 30000
        });
        const imageBuffer = Buffer.from(response.data);
        // NSFW –ø—Ä–æ–≤–µ—Ä–∫–∞ (–µ—Å–ª–∏ –Ω–µ –æ—Ç–∫–ª—é—á–µ–Ω–∞)
        let isNsfw = false;
        let nsfwScore = null;
        let nsfwCategories = undefined;
        if (!skipNsfwCheck) {
            try {
                const nsfwResult = await (0, nsfw_1.checkImageNsfw)(imageBuffer);
                isNsfw = nsfwResult.isNsfw;
                nsfwScore = nsfwResult.score;
                nsfwCategories = nsfwResult.predictions;
                console.log(`[NSFW] Image check result:`, {
                    isNsfw,
                    score: nsfwScore,
                    url: imageUrl
                });
            }
            catch (nsfwError) {
                console.error("[NSFW] Failed to check image:", nsfwError);
                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ NSFW –ø—Ä–æ–≤–µ—Ä–∫–∏
            }
        }
        const parsed = path_1.default.parse(new URL(imageUrl).pathname);
        const ext = parsed.ext || ".jpg";
        const filename = `${(0, uuid_1.v4)()}${ext}`;
        // üìÇ –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const dir = path_1.default.join(CDN_ROOT_PATH, telegramId.toString());
        await promises_1.default.mkdir(dir, { recursive: true });
        // üìÑ –ü–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
        const filepath = path_1.default.join(dir, filename);
        await promises_1.default.writeFile(filepath, imageBuffer);
        const publicUrl = `https://spectrmod.ru/api/cdn/image/${telegramId}/${filename}`;
        // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –º–æ–¥–µ–ª–∏ Image
        const newOrder = user.profile.images.length;
        const newImage = await prisma_1.prisma.image.create({
            data: {
                profileId: user.profile.id,
                url: publicUrl,
                order: newOrder,
                isNsfw,
                nsfwScore,
                nsfwCategories,
                format: ext.replace('.', '').toLowerCase()
            }
        });
        // –¢–∞–∫–∂–µ –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Å—Ç–∞—Ä—ã–π –º–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        const updated = await prisma_1.prisma.profile.update({
            where: { id: user.profile.id },
            data: {
                images: { push: publicUrl },
            },
            include: {
                imageData: {
                    orderBy: { order: 'asc' }
                }
            }
        });
        // –û–±–Ω–æ–≤–ª—è–µ–º trust score
        if (isNsfw) {
            await (0, trust_1.changeTrustScore)(user.id, trust_1.TrustChangeReason.NSFW_CONTENT, {
                imageUrl: publicUrl,
                nsfwScore
            });
        }
        else {
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ—Ç–æ –ø–æ–≤—ã—à–∞–µ—Ç trust score
            await (0, trust_1.changeTrustScore)(user.id, trust_1.TrustChangeReason.PHOTO_ADDED);
        }
        res.json({
            profile: updated,
            nsfwDetection: {
                checked: !skipNsfwCheck,
                isNsfw,
                score: nsfwScore
            },
            newImageRecord: {
                id: newImage.id,
                url: newImage.url,
                isNsfw: newImage.isNsfw,
                nsfwScore: newImage.nsfwScore
            }
        });
    }
    catch (err) {
        console.error("[API] add-media error:", err);
        res.status(500).json({ error: "Internal server error" });
    }
});
profileRouter.post("/profile/update", auth_1.authMiddleware, async (req, res) => {
    const userId = req.userId;
    const { preferredName, gender, birthYear, city, goals, description, images, // –ø–æ–ª–Ω—ã–π —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ url –∏–ª–∏ undefined, —á—Ç–æ–±—ã –Ω–µ –∏–∑–º–µ–Ω—è—Ç—å
     } = req.body;
    try {
        const existing = await prisma_1.prisma.profile.findUnique({ where: { userId } });
        if (!existing) {
            res.status(404).json({ error: "Profile not found" });
            return;
        }
        const dataToUpdate = {};
        if (preferredName !== undefined)
            dataToUpdate.preferredName = preferredName;
        if (gender !== undefined)
            dataToUpdate.gender = gender;
        if (birthYear !== undefined)
            dataToUpdate.birthYear = birthYear;
        if (city !== undefined)
            dataToUpdate.city = city;
        if (description !== undefined)
            dataToUpdate.description = description;
        if (goals !== undefined) {
            if (!Array.isArray(goals) || goals.length === 0) {
                res.status(400).json({ error: "Goals must be a non-empty array" });
                return;
            }
            dataToUpdate.goals = goals;
        }
        if (images !== undefined) {
            if (!Array.isArray(images)) {
                res.status(400).json({ error: "Images must be an array" });
                return;
            }
            let finalImages = images.filter((url) => typeof url === "string" && url.trim() !== "");
            // –ï—Å–ª–∏ –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π ‚Äì –ø—Ä–∏–º–µ–Ω—è–µ–º fallback
            if (finalImages.length === 0) {
                const user = await prisma_1.prisma.user.findUnique({ where: { id: userId } });
                // 1. –ü—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å –∞–≤—É –∏–∑ Telegram (photo_url —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ tgUser? –Ω–µ—Ç ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º dicebear)
                //    –†–µ–∞–ª—å–Ω—ã–π URL Telegram-–∞–≤—ã –ø–æ–ª—É—á–∏—Ç—å –±–µ–∑ Bot API —Å–ª–æ–∂–Ω–æ, –ø–æ—ç—Ç–æ–º—É fallback ‚Üí dicebear.
                const fallback = user?.username
                    ? `https://api.dicebear.com/7.x/thumbs/svg?seed=${Math.floor(Math.random() * 1000000)}`
                    : undefined;
                if (fallback)
                    finalImages = [fallback];
            }
            dataToUpdate.images = finalImages;
        }
        const updated = await prisma_1.prisma.profile.update({ where: { id: existing.id }, data: dataToUpdate });
        res.json({ profile: updated });
    }
    catch (err) {
        console.error("[API] update profile error", err);
        res.status(500).json({ error: "Internal server error" });
    }
});
// –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω—É–∂–Ω–∞ –ª–∏ –º–∏–≥—Ä–∞—Ü–∏—è –≥–æ—Ä–æ–¥–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
profileRouter.get("/profile/check-city-migration", auth_1.authMiddleware, async (req, res) => {
    try {
        const userId = req.userId;
        const profile = await prisma_1.prisma.profile.findUnique({
            where: { userId },
            select: { city: true }
        });
        if (!profile) {
            res.status(404).json({ error: "Profile not found" });
            return;
        }
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∞–ª–∏–¥–µ–Ω –ª–∏ —Ç–µ–∫—É—â–∏–π –≥–æ—Ä–æ–¥
        // –°—á–∏—Ç–∞–µ–º –≥–æ—Ä–æ–¥ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–º –µ—Å–ª–∏:
        // 1. –°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–µ–Ω–µ–µ 2 —Å–∏–º–≤–æ–ª–æ–≤)
        // 2. –°–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞
        // 3. –ù–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–ø—è—Ç—É—é (–Ω–µ—Ç —Ä–µ–≥–∏–æ–Ω–∞)
        const city = profile.city || '';
        const suspiciousWords = ['–º–æ–π', '–Ω–∞—à', '—Ç–µ—Å—Ç', 'test', '–¥–æ–º'];
        // –°–ø–∏—Å–æ–∫ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ç—Ä–µ–±—É—é—Ç —Ä–µ–≥–∏–æ–Ω–∞
        const popularCities = [
            '–º–∏–Ω—Å–∫', '–∫–∏–µ–≤', '–∞–ª–º–∞—Ç—ã', '—Ç–∞—à–∫–µ–Ω—Ç', '–±–∞–∫—É', '–µ—Ä–µ–≤–∞–Ω', '—Ç–±–∏–ª–∏—Å–∏',
            '–º–æ—Å–∫–≤–∞', '—Å–ø–±', '–≤–∞—Ä—à–∞–≤–∞', '–ø—Ä–∞–≥–∞', '—Ä–∏–≥–∞', '—Ç–∞–ª–ª–∏–Ω–Ω', '–≤–∏–ª—å–Ω—é—Å',
            '–æ–¥–µ—Å—Å–∞', '—Ö–∞—Ä—å–∫–æ–≤', '–¥–Ω–µ–ø—Ä', '–ª—å–≤–æ–≤', '–¥–æ–Ω–µ—Ü–∫', '–∑–∞–ø–æ—Ä–æ–∂—å–µ',
            '–∞—Å—Ç–∞–Ω–∞', '—à—ã–º–∫–µ–Ω—Ç', '–∞–∫—Ç–æ–±–µ', '–∫–∞—Ä–∞–≥–∞–Ω–¥–∞', '–ø–∞–≤–ª–æ–¥–∞—Ä', '—É—Å—Ç—å-–∫–∞–º–µ–Ω–æ–≥–æ—Ä—Å–∫'
        ];
        const cityLower = city.toLowerCase();
        const isPopularCity = popularCities.some(popular => cityLower.includes(popular));
        const needsMigration = city.length < 2 ||
            city.length > 100 ||
            suspiciousWords.some(word => cityLower.includes(word)) ||
            (!city.includes(',') && city.length < 4 && !isPopularCity) || // –û—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –±–µ–∑ —Ä–µ–≥–∏–æ–Ω–∞ (–Ω–æ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –≥–æ—Ä–æ–¥–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω—ã)
            /^\d+$/.test(city) || // –¢–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã
            (cityLower === city && city.length < 4); // –¢–æ–ª—å–∫–æ —Å—Ç—Ä–æ—á–Ω—ã–µ –∏ –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–µ
        res.json({
            needsMigration,
            currentCity: city
        });
    }
    catch (error) {
        console.error("[PROFILE] City migration check error:", error);
        res.status(500).json({
            error: "Failed to check city migration",
            message: error.message
        });
    }
});
// –ú–∏–≥—Ä–∞—Ü–∏—è –≥–æ—Ä–æ–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
profileRouter.post("/profile/migrate-city", auth_1.authMiddleware, async (req, res) => {
    try {
        const userId = req.userId;
        const { newCity } = req.body;
        if (!newCity || typeof newCity !== 'string') {
            res.status(400).json({ error: "New city is required" });
            return;
        }
        const trimmedCity = newCity.trim();
        if (trimmedCity.length < 2 || trimmedCity.length > 100) {
            res.status(400).json({ error: "City name must be between 2 and 100 characters" });
            return;
        }
        // –û–±–Ω–æ–≤–ª—è–µ–º –≥–æ—Ä–æ–¥ –≤ –ø—Ä–æ—Ñ–∏–ª–µ
        const updatedProfile = await prisma_1.prisma.profile.update({
            where: { userId },
            data: {
                city: trimmedCity
            },
            select: {
                id: true,
                city: true,
                preferredName: true
            }
        });
        console.log(`[PROFILE] City migrated for user ${userId}: "${trimmedCity}"`);
        res.json({
            success: true,
            profile: updatedProfile,
            message: "City updated successfully"
        });
    }
    catch (error) {
        console.error("[PROFILE] City migration error:", error);
        res.status(500).json({
            error: "Failed to migrate city",
            message: error.message
        });
    }
});
// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–∏–≥—Ä–∞—Ü–∏–∏ (–¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
profileRouter.get("/profile/migration-stats", auth_1.authMiddleware, async (req, res) => {
    try {
        // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –∞–¥–º–∏–Ω—Å–∫–∏–π –∑–∞–ø—Ä–æ—Å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É
        // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –∑–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–æ–ª–∏ –∞–¥–º–∏–Ω–∞
        const allProfiles = await prisma_1.prisma.profile.findMany({
            select: { city: true }
        });
        const suspiciousWords = ['–º–æ–π', '–Ω–∞—à', '—Ç–µ—Å—Ç', 'test', '–¥–æ–º'];
        // –°–ø–∏—Å–æ–∫ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ç—Ä–µ–±—É—é—Ç —Ä–µ–≥–∏–æ–Ω–∞
        const popularCities = [
            '–º–∏–Ω—Å–∫', '–∫–∏–µ–≤', '–∞–ª–º–∞—Ç—ã', '—Ç–∞—à–∫–µ–Ω—Ç', '–±–∞–∫—É', '–µ—Ä–µ–≤–∞–Ω', '—Ç–±–∏–ª–∏—Å–∏',
            '–º–æ—Å–∫–≤–∞', '—Å–ø–±', '–≤–∞—Ä—à–∞–≤–∞', '–ø—Ä–∞–≥–∞', '—Ä–∏–≥–∞', '—Ç–∞–ª–ª–∏–Ω–Ω', '–≤–∏–ª—å–Ω—é—Å',
            '–æ–¥–µ—Å—Å–∞', '—Ö–∞—Ä—å–∫–æ–≤', '–¥–Ω–µ–ø—Ä', '–ª—å–≤–æ–≤', '–¥–æ–Ω–µ—Ü–∫', '–∑–∞–ø–æ—Ä–æ–∂—å–µ',
            '–∞—Å—Ç–∞–Ω–∞', '—à—ã–º–∫–µ–Ω—Ç', '–∞–∫—Ç–æ–±–µ', '–∫–∞—Ä–∞–≥–∞–Ω–¥–∞', '–ø–∞–≤–ª–æ–¥–∞—Ä', '—É—Å—Ç—å-–∫–∞–º–µ–Ω–æ–≥–æ—Ä—Å–∫'
        ];
        let needMigration = 0;
        let validCities = 0;
        const invalidCities = [];
        allProfiles.forEach(profile => {
            const city = profile.city || '';
            const cityLower = city.toLowerCase();
            const isPopularCity = popularCities.some(popular => cityLower.includes(popular));
            const isInvalid = city.length < 2 ||
                city.length > 100 ||
                suspiciousWords.some(word => cityLower.includes(word)) ||
                (!city.includes(',') && city.length < 4 && !isPopularCity) ||
                /^\d+$/.test(city) ||
                (cityLower === city && city.length < 4);
            if (isInvalid) {
                needMigration++;
                if (invalidCities.length < 20) { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 20 –ø—Ä–∏–º–µ—Ä–æ–≤
                    invalidCities.push(city);
                }
            }
            else {
                validCities++;
            }
        });
        res.json({
            total: allProfiles.length,
            needMigration,
            validCities,
            migrationPercentage: Math.round((needMigration / allProfiles.length) * 100),
            exampleInvalidCities: invalidCities
        });
    }
    catch (error) {
        console.error("[PROFILE] Migration stats error:", error);
        res.status(500).json({
            error: "Failed to get migration stats",
            message: error.message
        });
    }
});
// –°–æ–∑–¥–∞—Ç—å –∂–∞–ª–æ–±—É –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
profileRouter.post("/complaints", auth_1.authMiddleware, async (req, res) => {
    try {
        const reporterId = req.userId;
        const { userId, reason, details, type = 'other' } = req.body;
        if (!userId || !reason) {
            res.status(400).json({ error: "userId and reason are required" });
            return;
        }
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∂–∞–ª—É–µ—Ç—Å—è —Å–∞–º –Ω–∞ —Å–µ–±—è
        if (reporterId === userId) {
            res.status(400).json({ error: "Cannot report yourself" });
            return;
        }
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        const targetUser = await prisma_1.prisma.user.findUnique({
            where: { id: userId },
            select: { id: true, firstName: true }
        });
        if (!targetUser) {
            res.status(404).json({ error: "User not found" });
            return;
        }
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ–¥–∞–≤–∞–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∂–∞–ª–æ–±—É –Ω–∞ —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ–¥–∞–≤–Ω–æ
        const recentComplaint = await prisma_1.prisma.complaint.findFirst({
            where: {
                reporterId,
                userId,
                createdAt: {
                    gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // –ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞
                }
            }
        });
        if (recentComplaint) {
            res.status(429).json({ error: "You can only report the same user once per day" });
            return;
        }
        // –°–æ–∑–¥–∞–µ–º –∂–∞–ª–æ–±—É
        const complaint = await prisma_1.prisma.complaint.create({
            data: {
                reporterId,
                userId,
                reason,
                description: details || "",
                type,
                status: 'pending',
                priority: 'medium'
            }
        });
        console.log(`[COMPLAINTS] New complaint created: ${complaint.id} by ${reporterId} against ${userId}`);
        res.json({
            success: true,
            complaintId: complaint.id,
            message: "Complaint submitted successfully"
        });
    }
    catch (error) {
        console.error("[COMPLAINTS] Error creating complaint:", error);
        res.status(500).json({
            error: "Failed to submit complaint",
            message: error.message
        });
    }
});
// --- Account delete route ---
profileRouter.post('/account/delete', auth_1.authMiddleware, async (req, res) => {
    const userId = req.userId;
    try {
        console.log(`[PROFILE] Starting account deletion for user ${userId}`);
        // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const profile = await prisma_1.prisma.profile.findUnique({
            where: { userId },
            include: { imageData: true }
        });
        // –ü–æ–ª—É—á–∞–µ–º —á–∞—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const chats = await prisma_1.prisma.chat.findMany({
            where: { OR: [{ userAId: userId }, { userBId: userId }] },
            select: { id: true }
        });
        const chatIds = chats.map(c => c.id);
        // –í—ã–ø–æ–ª–Ω—è–µ–º —É–¥–∞–ª–µ–Ω–∏–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
        await prisma_1.prisma.$transaction(async (tx) => {
            console.log(`[PROFILE] Deleting related data for user ${userId}`);
            // 1. –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
            if (chatIds.length > 0) {
                await tx.message.deleteMany({
                    where: { chatId: { in: chatIds } }
                });
                console.log(`[PROFILE] Deleted messages from ${chatIds.length} chats`);
            }
            // 2. –£–¥–∞–ª—è–µ–º —á–∞—Ç—ã
            if (chatIds.length > 0) {
                await tx.chat.deleteMany({
                    where: { id: { in: chatIds } }
                });
                console.log(`[PROFILE] Deleted ${chatIds.length} chats`);
            }
            // 3. –£–¥–∞–ª—è–µ–º –ª–∞–π–∫–∏
            if (profile) {
                await tx.like.deleteMany({
                    where: {
                        OR: [
                            { fromUserId: userId },
                            { toProfileId: profile.id }
                        ]
                    }
                });
                console.log(`[PROFILE] Deleted likes for user ${userId}`);
            }
            // 4. –£–¥–∞–ª—è–µ–º –º–∞—Ç—á–∏
            await tx.match.deleteMany({
                where: {
                    OR: [{ user1Id: userId }, { user2Id: userId }]
                }
            });
            console.log(`[PROFILE] Deleted matches for user ${userId}`);
            // 5. –£–¥–∞–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è
            if (profile?.imageData) {
                await tx.image.deleteMany({
                    where: { profileId: profile.id }
                });
                console.log(`[PROFILE] Deleted ${profile.imageData.length} images`);
            }
            // 6. –£–¥–∞–ª—è–µ–º trust logs
            await tx.trustLog.deleteMany({ where: { userId } });
            // 7. –£–¥–∞–ª—è–µ–º –∂–∞–ª–æ–±—ã
            await tx.complaint.deleteMany({
                where: {
                    OR: [
                        { userId },
                        { reporterId: userId }
                    ]
                }
            });
            // 8. –£–¥–∞–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤
            await tx.moderatorAction.deleteMany({
                where: {
                    OR: [
                        { userId },
                        { moderatorId: userId }
                    ]
                }
            });
            // 9. –£–¥–∞–ª—è–µ–º –∫–ª–∏–∫–∏ –ø–æ —Ä–µ–∫–ª–∞–º–µ
            await tx.adUserClick.deleteMany({ where: { userId } });
            // 10. –£–¥–∞–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            await tx.settings.deleteMany({ where: { userId } });
            console.log(`[PROFILE] Deleted settings for user ${userId}`);
            // 11. –£–¥–∞–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å
            if (profile) {
                await tx.profile.delete({ where: { id: profile.id } });
                console.log(`[PROFILE] Deleted profile for user ${userId}`);
            }
            // 12. –£–¥–∞–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            await tx.user.delete({ where: { id: userId } });
            console.log(`[PROFILE] Deleted user ${userId}`);
        });
        console.log(`[PROFILE] Account deletion completed for user ${userId}`);
        res.json({ success: true, message: "Account deleted successfully" });
    }
    catch (err) {
        console.error(`[PROFILE] Account deletion error for user ${userId}:`, err);
        res.status(500).json({
            error: 'Failed to delete account',
            message: err instanceof Error ? err.message : 'Unknown error'
        });
    }
});
